" ============================================================================
" Vim-plug initialization
" http://fisadev.github.io/fisa-vim-config/

let vim_plug_just_installed = 0
let vim_plug_path = expand('~/.vim/autoload/plug.vim')
if !filereadable(vim_plug_path)
    echo "Installing Vim-plug..."
    echo ""
    silent !mkdir -p ~/.vim/autoload
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    let vim_plug_just_installed = 1
endif

" manually load vim-plug the first time
if vim_plug_just_installed
    :execute 'source '.fnameescape(vim_plug_path)
endif

" Plugins ---------------------------------------{{{

call plug#begin('~/.vim/plugged')
" Plug 'akinsho/bufferline.nvim', { 'tag': 'v3.*' }
Plug 'projekt0n/github-nvim-theme', { 'tag': 'v0.0.7' }

Plug 'epwalsh/obsidian.nvim'

Plug 'folke/which-key.nvim'
Plug 'mrjones2014/legendary.nvim'
Plug 'stevearc/dressing.nvim'

Plug 'ray-x/sad.nvim'
Plug 'ray-x/guihua.lua'

Plug 'dyng/ctrlsf.vim'

Plug 'christianchiarulli/nvcode-color-schemes.vim'

Plug 'amadeus/vim-mjml'
Plug 'smjonas/live-command.nvim',
Plug 'nvim-lua/plenary.nvim',
Plug 'MunifTanjim/nui.nvim',
Plug 'nvim-neo-tree/neo-tree.nvim', { 'branch': 'v2.x' }

Plug 'antoinemadec/FixCursorHold.nvim'
Plug 'nvim-neotest/neotest'
Plug 'haydenmeade/neotest-jest'

Plug 'nvim-treesitter/nvim-treesitter-context'
Plug 'nvim-treesitter/playground'
Plug 'stevearc/aerial.nvim'

Plug 'lewis6991/spellsitter.nvim'
Plug 'github/copilot.vim'
Plug 'junegunn/goyo.vim'
Plug 'junegunn/limelight.vim'
Plug 'ziontee113/syntax-tree-surfer'
Plug 'brooth/far.vim'

"Plug 'liuchengxu/vim-which-key'
Plug 'sindrets/diffview.nvim'
Plug 'kyazdani42/nvim-web-devicons'

Plug 'https://github.com/morhetz/gruvbox.git'
Plug 'ericbn/vim-solarized'
" Plug 'ulwlu/elly.vim'
Plug 'cormacrelf/vim-colors-github'
Plug 'ayu-theme/ayu-vim'

Plug 'tpope/vim-commentary'
Plug 'suy/vim-context-commentstring' " needed for vim-commentary
Plug 'meain/vim-package-info', { 'do': 'npm install' }
Plug 'haya14busa/is.vim'
Plug 'bronson/vim-visual-star-search'

Plug 'https://github.com/edkolev/tmuxline.vim.git'
Plug 'https://github.com/MarcWeber/vim-addon-mw-utils.git'
Plug 'https://github.com/vim-airline/vim-airline.git'

" git
Plug 'https://github.com/tpope/vim-fugitive.git'
Plug 'https://github.com/tpope/vim-rhubarb'
Plug 'junegunn/gv.vim'
Plug 'https://github.com/airblade/vim-gitgutter.git'
Plug 'rhysd/git-messenger.vim'

" tpope classics
Plug 'https://github.com/tpope/vim-repeat.git'
Plug 'https://github.com/tpope/vim-surround.git'
Plug 'https://github.com/tpope/vim-sleuth.git'
Plug 'https://github.com/tpope/vim-unimpaired.git'
" Plug 'tpope/vim-vinegar'
" Plug 'justinmk/vim-dirvish'
" Plug 'roginfarrer/vim-dirvish-dovish'

Plug 'justinmk/vim-sneak'

Plug 'https://github.com/christoomey/vim-tmux-navigator.git'

Plug 'neoclide/coc.nvim', {'do': { -> coc#util#install()}}

Plug 'andys8/vim-elm-syntax'

Plug 'mfussenegger/nvim-dap'

Plug 'cbochs/portal.nvim'

Plug 'kevinhwang91/nvim-bqf'

Plug 'inkarkat/vim-EnhancedJumps'
Plug 'inkarkat/vim-ingo-library'

Plug 'andymass/vim-visput'
set signcolumn=number
let g:coc_global_extensions = [
\ 'coc-json',
\ 'coc-tsserver',
\ 'coc-eslint',
\ 'coc-html',
\ 'coc-css',
\ 'coc-yaml',
\ 'coc-highlight',
\ 'coc-rust-analyzer',
\ 'coc-vimlsp',
\ 'coc-snippets',
\ 'coc-react-refactor',
\ 'coc-yank',
\ 'coc-lists',
\ 'coc-fzf-preview',
\ 'coc-protobuf',
\ 'coc-spell-checker',
\ 'coc-sh',
\ ]
" \ 'coc-tabnine',

Plug 'machakann/vim-highlightedyank'
Plug '/opt/homebrew/opt/fzf'
Plug 'junegunn/fzf.vim'

Plug 'wellle/targets.vim'

" Scratch buffer
Plug 'mtth/scratch.vim'

" Plug 'vimwiki/vimwiki'

Plug 'janko/vim-test'

Plug 'nvim-treesitter/nvim-treesitter'
Plug 'stevearc/oil.nvim'
Plug 'jxnblk/vim-mdx-js'

Plug 'nvim-lua/popup.nvim'
Plug 'nvim-telescope/telescope.nvim'
Plug 'nvim-telescope/telescope-symbols.nvim'

Plug 'kevinhwang91/promise-async'
Plug 'kevinhwang91/nvim-ufo'
Plug 'luukvbaal/statuscol.nvim'

Plug 'chentoast/marks.nvim'

Plug 'jackMort/ChatGPT.nvim'

Plug 'mg979/vim-visual-multi', {'branch': 'master'}

call plug#end()

nnoremap <silent> <leader> :WhichKey ' '<CR>
" ============================================================================
" Install plugins the first time vim runs

if vim_plug_just_installed
    echo "Installing Bundles, please ignore key map error messages"
    :PlugInstall
endif

" ============================================================================
autocmd FileType gitcommit setlocal spell

" Basic options ----------------------------------------{{{
set nocompatible

syntax on
filetype plugin indent on

" leader mapping
let mapleader = ' '

" make backspace work like most other programs
set backspace=2
set history=200

"set keyword for temporatry higlite switch off
set hls
set incsearch

set number
" set relativenumber
set mouse=a
set autoindent
set nowrap

set expandtab
set shiftwidth=2

set list          " Display unprintable characters f12 - switches
set listchars=tab:•\ ,trail:•,extends:»,precedes:« " Unprintable chars mapping

"" ========== Theme ==========
" colorscheme github_dimmed
set termguicolors

" Optionally reset the cursor on start:
augroup myCmds
au!
autocmd VimEnter * silent !echo -ne "\e[2 q"
augroup END

" For VimGutter
set updatetime=400
" }}}

" allow close unsaved buffer
set hidden

" Mappings ----------------------------------------{{{
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" airline
let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts = 1
" let g:airline_inactive_collapse=1
let g:airline#extensions#tabline#left_sep = ' '
let g:airline#extensions#tabline#left_alt_sep = '|'
let g:airline_extensions = ['tmuxline', 'quickfix', 'coc']
let g:airline_section_c='%<%#__accent_red#%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#%#__accent_bold#%{airline#util#wrap(airline#extensions#coc#get_status(),0)}%#__restore__#%#__accent_bold#%#__restore__#'
" show me the git branch
let g:airline#extensions#branch#enabled=1

" Save with treesitter reset
nnoremap <silent> <S-s> :write \| edit \| TSBufEnable highlight<CR>
" <Command-S> is bound to <M--> in alacritty config
nnoremap <silent> <M--> :write \| edit \| TSBufEnable highlight<CR>

" use system clipboard
set clipboard+=unnamedplus

" the rg search on grep
set grepprg=rg\ --vimgrep\ --no-heading\ --smart-case\ --hidden\ --glob\ \"!**/.git/**\"
set grepformat=%f:%l:%c:%m,%f:%l:%m

" command! -bang -nargs=* Rg
"   \ call fzf#vim#grep(
"   \   'rg --column --line-number --no-heading --color=always --smart-case --hidden -- '.shellescape(<q-args>), 1,
"   \   fzf#vim#with_preview(), <bang>0)

" command! -bang -nargs=* Rg
"       call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case --hidden --glob !**/.git/**" . <q-args>, 1, fzf#vim#with_preview(), <bang>0)
"   \ call fzf#vim#grep(
"   \   'rg --column --line-number --no-heading --color=always --smart-case --hidden\ --glob\ \"!**/.git/**\ -- '.shellescape(<q-args>), 1,
"   \   fzf#vim#with_preview(), <bang>0)

noremap <S-h> ^
noremap <S-l> $
noremap <C-6> :e#

let $FZF_DEFAULT_COMMAND = 'fd -H -E .git'
" let $FZF_DEFAULT_COMMAND = 'fd -H -E .git --type file'
nnoremap <silent> <leader>b :Buffers<cr>
nnoremap <silent> <leader>/ :BLines<cr>
nnoremap <silent> <leader>h :History<cr>
nnoremap <silent> <leader>H :Helptags<cr>
" nnoremap <leader>: :Commands<cr>

let g:fzf_preview_command = 'bat --color=always --plain {-1}'
let g:fzf_preview_filelist_command = 'fd -H -E .git'
" https://www.reddit.com/r/vim/comments/kaedj9/implemented_fzfpreviewvim_with_gitdelta_in_vim/
let g:fzf_preview_git_status_preview_command = "git diff --color=always -- {-1}"
    "\ "[[ $(git diff --cached -- {-1}) != \"\" ]] && git diff --cached --color=always -- {-1} | delta || " .
    "\ "[[ $(git diff -- {-1}) != \"\" ]] && git diff --color=always -- {-1} "
    "\ g:fzf_preview_command

let g:fzf_preview_fzf_preview_window_option = 'up:60%'

let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.9 } }
let g:fzf_preview_window = ['up:70%', 'ctrl-/']

" nnoremap <leader>e :<C-u>CocCommand fzf-preview.DirectoryFiles<CR>
nnoremap <silent> <Leader>fp     :<C-u>CocCommand fzf-preview.FromResources project_mru git<CR>
nnoremap <silent> <Leader>fgs    :<C-u>CocCommand fzf-preview.GitStatus<CR>
nnoremap <silent> <Leader>fga    :<C-u>CocCommand fzf-preview.GitActions<CR>
nnoremap <silent> <Leader>fb     :<C-u>CocCommand fzf-preview.Buffers<CR>
nnoremap <silent> <Leader>fB     :<C-u>CocCommand fzf-preview.AllBuffers<CR>
nnoremap <silent> <Leader>fo     :<C-u>CocCommand fzf-preview.FromResources buffer project_mru<CR>
nnoremap <silent> <Leader>f<C-o> :<C-u>CocCommand fzf-preview.Jumps<CR>
nnoremap <silent> <Leader>fg;    :<C-u>CocCommand fzf-preview.Changes<CR>
nnoremap <silent> <Leader>f/     :<C-u>CocCommand fzf-preview.Lines --add-fzf-arg=--no-sort --add-fzf-arg=--query="'"<CR>
nnoremap <silent> <Leader>f*     :<C-u>CocCommand fzf-preview.Lines --add-fzf-arg=--no-sort --add-fzf-arg=--query="'<C-r>=expand('<cword>')<CR>"<CR>
nnoremap <silent> <Leader>fgr    :<C-u>CocCommand fzf-preview.ProjectGrep<Space>
xnoremap <silent> <Leader>fgr    "sy:CocCommand   fzf-preview.ProjectGrep<Space>-F<Space>"<C-r>=substitute(substitute(@s, '\n', '', 'g'), '/', '\\/', 'g')<CR>"
nnoremap <silent> <Leader>ft     :<C-u>CocCommand fzf-preview.BufferTags<CR>
nnoremap <silent> <Leader>fq     :<C-u>CocCommand fzf-preview.QuickFix<CR>
nnoremap <silent> <Leader>fl     :<C-u>CocCommand fzf-preview.LocationList<CR>

nnoremap <silent> <leader>gg :GFiles?<cr>

nnoremap <silent> tc :tabc<cr>

" some abbreviations
iabbrev lenght length

" default split position
set splitright
set splitbelow

noremap <silent> Q :q<cr>

" splits
noremap <silent> <leader>sh :call OpenSplit('h')<cr>
noremap <silent> <leader>sl :call OpenSplit('l')<cr>
noremap <silent> <leader>sk :call OpenSplit('k')<cr>
noremap <silent> <leader>sj :call OpenSplit('j')<cr>
noremap <silent> <leader>sfh :call OpenSplit('h')<cr>gf
noremap <silent> <leader>sfl :call OpenSplit('l')<cr>gf
noremap <silent> <leader>sfk :call OpenSplit('k')<cr>gf
noremap <silent> <leader>sfj :call OpenSplit('j')<cr>gf
noremap <silent> <leader>sth :call OpenSplit('h')<cr>:term<cr>i
noremap <silent> <leader>stl :call OpenSplit('l')<cr>:term<cr>i
noremap <silent> <leader>stk :call OpenSplit('k')<cr>:term<cr>i
noremap <silent> <leader>stj :call OpenSplit('j')<cr>:term<cr>i
noremap <silent> <leader>srh :call OpenSplit('h')<cr>:e.<cr>
noremap <silent> <leader>srl :call OpenSplit('l')<cr>:e.<cr>
noremap <silent> <leader>srk :call OpenSplit('k')<cr>:e.<cr>
noremap <silent> <leader>srj :call OpenSplit('j')<cr>:e.<cr>

nnoremap <silent> <leader>id :read !date -u +"\%Y-\%m-\%d \%A"<cr>
nnoremap <silent> <leader>iw :read !date +"Week \%U"<cr>

" Make Y behave more like other operators.
nnoremap <silent> Y y$

" Save cursor position for reopening.
au BufReadPost *
  \ if line("'\"") > 0 && line ("'\"") <= line("$") |
  \   exe "normal! g'\"" |
  \ endif

set nospell
set ignorecase
set smartcase
set scrolljump=5                " lines to scroll when cursor leaves screen
set scrolloff=3                 " minimum lines to keep above and below cursor
set gdefault                    " the /g flag on :s substitutions
set tabstop=4

augroup filetype_git
    autocmd!
    autocmd FileType git :norm zM<CR>
augroup END

" shotcuts for location and quickfix windows
" nmap <silent> <leader>w :call ToggleList("Location List", 'l')<CR>
nmap <silent> <leader>q :call ToggleList("Quickfix List", 'c')<CR>

" clean white space
nnoremap <silent> <leader>ss :let _s=@/ <Bar> :%s/\s\+$//e <Bar> :let @/=_s <Bar> :nohl <Bar> :unlet _s <CR>

" git diff options
set diffopt=filler,vertical
set diffopt+=algorithm:patience

" terminal escape
tnoremap <Esc> <C-\><C-n>

set inccommand=split
" select just pasted text
nnoremap <silent> gp `[v`]

" augroup BgHighlight
"     autocmd!
"     autocmd WinEnter * set cursorline
"     autocmd WinEnter * set cursorcolumn
"     autocmd WinLeave * set nocursorline
"     autocmd WinLeave * set nocursorcolumn
" augroup END

" refactor expression to var
" nnoremap <leader>r ".pIconst <esc>A = <esc>""p=`]`]A;<esc>

" vim-test
nmap <silent><leader>xt <leader>os:TestNearest<cr>
nmap <silent><leader>xf <leader>os:TestFile<cr>
nmap <silent><leader>xl <leader>os:TestLast<cr>
" Coc
" Some servers have issues with backup files
set nobackup
set nowritebackup

" Use <cr> to confirm completion, `<C-g>u` means break undo chain at current position.
" Coc only does snippet and additional edit on confirm.
inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

" Highlight symbol under cursor on CursorHold
" autocmd CursorHold * :echo("abc")
autocmd CursorHold * call CocActionAsync('highlight')
highlight CocHighlightText gui=NONE guifg=NONE guibg=#3D2806

nmap <silent>gd <Plug>(coc-definition)
nmap <silent>gy <Plug>(coc-type-definition)
nmap <leader>tf <Plug>(coc-codeaction)
nmap <leader>tc <Plug>(coc-fix-current)
"nmap <leader>tl <Plug>(coc-codelens-action)
nmap <leader>te <Plug>(coc-diagnostic-info)
nmap <leader>tg <Plug>(coc-declaration)
map <leader>tj <Plug>(coc-refactor)
nmap <leader>su <Plug>(coc-float-jump) :topleft sp<cr>:execute('resize ' . (line('$') + 2))<cr>
nmap ]g <Plug>(coc-diagnostic-next-error)
nmap [g <Plug>(coc-diagnostic-prev-error)

nmap <silent> <leader>tr <Plug>(coc-rename)
nmap <silent> <leader>ta <Plug>(coc-references)
nmap <silent> <leader>tt :call CocAction('doHover')<cr>
nmap <silent> <leader>cc :CocCommand<cr>

" nnoremap <silent> <leader>z :Prettier<cr>
nmap <silent> <leader>z <Plug>(coc-format)
"nnoremap <leader>z :CocCommand eslint.executeAutofix<cr>


nmap <silent> <leader>tl :CocList<cr>

command! -nargs=0 Prettier :CocCommand prettier.formatFile
nmap <silent> <leader>tp :Prettier<cr>

nmap <silent> <leader>td :CocDiagnostics<cr>
" Introduce function text object
" NOTE: Requires 'textDocument.documentSymbol' support from the language server.
xmap if <Plug>(coc-funcobj-i)
xmap af <Plug>(coc-funcobj-a)
omap if <Plug>(coc-funcobj-i)
omap af <Plug>(coc-funcobj-a)

nnoremap <silent> <leader>ts  :<C-u>CocList -I symbols<cr>

" Use <TAB> for selections ranges.
" NOTE: Requires 'textDocument/selectionRange' support from the language server.
" coc-tsserver, coc-python are the examples of servers that support it.
" nmap <silent> <TAB> <Plug>(coc-range-select)
vmap <silent> <TAB> <Plug>(coc-range-select)

nmap <silent><leader>tm <Plug>(coc-codeaction-selected)<cr>
xmap <silent><leader>tm <Plug>(coc-codeaction-selected)<cr>
xmap <silent><leader>tp <Plug>(coc-codeaction)<cr>

nnoremap <silent> <leader>ty  :<C-u>CocList -A --normal yank<cr>
xnoremap <silent> <leader>ty  :<C-u>CocList -A --normal yank<cr>

imap <tab> <Plug>(coc-snippets-expand-jump)

nnoremap <silent> <leader>to :CocCommand tsserver.organizeImports<cr>:CocCommand eslint.executeAutofix<cr>
nnoremap <silent> <leader>tw :CocCommand tsserver.watchBuild<cr>

augroup ctrl_m_definition
    autocmd!
    autocmd FileType typescript.tsx,typescriptreact,typescript,javascript,javascriptreact,javascript.tsx,rust,stylable,vim,haskell,proto nnoremap <buffer> <cr> <Plug>(coc-definition)
    autocmd FileType typescript.tsx,typescriptreact,typescript,javascript,javascript.tsx nnoremap <leader>z :CocCommand eslint.executeAutofix<cr>
augroup END
"replace the word under cursor
" nnoremap <leader>* :%s/\<<c-r><c-w>\>//g<left><left>
" TODO work on visual mode: xnoremap <leader>* :<C-u>%s/\<<c-r><c-w>\>//g<left><left>

" use ag for recursive searching so we don't find 10,000 useless hits inside node_modules
"nnoremap <leader>* :call ag#Ag('grep', '--literal ' . shellescape(expand("<cword>")))<CR>
" vnoremap <leader>* :<C-u>call VisualStarSearchSet('/', 'raw')<CR>:call ag#Ag('grep', '--literal ' . shellescape(@/))<CR>

nnoremap  <silent> <leader>* :execute 'Rg' '--fixed-strings' shellescape(expand("<cword>"))<CR>
vnoremap <silent> <leader>* :<C-u>call VisualStarSearchSet('/', 'raw')<CR>:execute 'Rg' '--fixed-strings' "'" . @/ . "'"<CR>

" nnoremap  <leader>r :execute 'Grep' shellescape(expand("<cword>"))<CR>:execute 'cdo %s/' shellescape(expand("<cword>")) '/'
nnoremap <silent> <leader>r :RenameAll<cr>
" Type a replacement term and press . to repeat the replacement again. Useful
" for replacing a few instances of the term (comparable to multiple cursors).
nnoremap <silent> c* :let @/='\<'.expand('<cword>').'\>'<CR>cgn
xnoremap <silent> c* "sy:let @/=@s<CR>cgn

" :h tcsh-style
cnoremap <C-A> <Home>
" cnoremap <C-F> <Right>
cnoremap <C-B> <Left>
" alt-b
cnoremap <Char-0x1B>b <S-Left>
cnoremap <Esc>f <S-Right>

" Allow passing optional flags into the Rg command.
"   Example: :Rg myterm -g '*.md'
command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \ "rg --column --line-number --no-heading --color=always --smart-case " .
  \ <q-args>, 1, fzf#vim#with_preview(), <bang>0)

" tmux
let g:tmux_navigator_disable_when_zoomed = 1
" Solves netrw using <C-L><C-H> which is used for jumping windows
" https://github.com/christoomey/vim-tmux-navigator/issues/53
augroup navigator_netrw_fix
  autocmd!
  autocmd FileType netrw nmap <buffer> <silent> <c-l> :TmuxNavigateRight<cr>
augroup END

packadd cfilter

source ~/.vim/scripts/fzf_js_import.vim
source ~/.vim/scripts/toggle_list.vim
source ~/.vim/scripts/open_split.vim
source ~/.vim/scripts/grep_operator.vim
source ~/.vim/scripts/git.vim
source ~/.vim/scripts/grep.vim
source ~/.vim/scripts/replace.vim
source ~/.vim/scripts/goyo.vim
source ~/.vim/scripts/tree_surfer.vim
source ~/.vim/scripts/execute-package-script.vim
" source ~/.vim/scripts/theme.vim

"camellcase
nnoremap <silent> ,c viwgu:s/_\([a-z]\)/\u\1/g<CR>

nmap <Leader>- <Plug>VimwikiRemoveHeaderLevel

set noswapfile

" let g:dirvish_mode = ':sort ,^.*[\/],'

" mfussenegger/nvim-dap
lua << EOF
local dap = require('dap')
dap.adapters.node2 = {
  type = 'executable',
  command = 'node',
  args = {os.getenv('HOME') .. '/b/vscode-node-debug2/out/src/nodeDebug.js'},
}
vim.fn.sign_define('DapBreakpoint', {text='🟥', texthl='', linehl='', numhl=''})
vim.fn.sign_define('DapStopped', {text='🟢', texthl='', linehl='', numhl=''})
EOF
nnoremap <silent> <leader>dh :lua require'dap'.toggle_breakpoint()<CR>
" nnoremap <S-k> :lua require'dap'.step_out()<CR>
" nnoremap <S-l> :lua require'dap'.step_into()<CR>
" nnoremap <S-j> :lua require'dap'.step_over()<CR>
nnoremap <silent> <leader>dn :lua require'dap'.continue()<CR>
nnoremap <silent> <leader>d_ :lua require'dap'.run_last()<CR>
nnoremap <silent> <leader>dr :lua require'dap'.repl.open({}, 'vsplit')<CR><C-w>l
nnoremap <silent> <leader>di :lua require'dap.ui.variables'.hover(function () return vim.fn.expand("<cexpr>") end)<CR>
vnoremap <silent> <leader>di :lua require'dap.ui.variables'.visual_hover()<CR>
nnoremap <silent> <leader>d? :lua require'dap.ui.variables'.scopes()<CR>
nnoremap <silent> <leader>de :lua require'dap'.set_exception_breakpoints({"all"})<CR>
nnoremap <silent> <leader>da :lua require'debugHelper'.attach()<CR>


" jank/vim-test and mfussenegger/nvim-dap
nnoremap <silent> <leader>dd :TestNearest -strategy=jest<CR>
function! JestStrategy(cmd)
  let testName = matchlist(a:cmd, '\v -t ''(.*)''')[1]
  let fileName = matchlist(a:cmd, '\v'' -- (.*)$')[1]
  call luaeval("require'debugHelper'.debugJest([[" . testName . "]], [[" . fileName . "]])")
endfunction
let g:test#custom_strategies = {'jest': function('JestStrategy')}

" Used for <Plug>(dovish_delete)
" function! g:DovishDelete(target) abort
"   return 'rm ' . a:target
" endfunction
nnoremap <silent> - :Neotree filesystem reveal current<CR>


" set foldmethod=expr
" set foldexpr=nvim_treesitter#foldexpr()

hi clear SpellBad
hi SpellBad cterm=underline

augroup JsonToJsonc
    autocmd! FileType json set filetype=jsonc
augroup END

nnoremap <silent> yog :Goyo<CR>
nnoremap <silent> yol :Limelight!!<CR>

let g:test#javascript#runner = "jest"
let g:test#javascript#jest#executable="yarn test"
" let g:test#javascript#jest#executable="yarn jest"

nnoremap <silent> \ :Neotree reveal<cr>

set title
set titlestring=%{hostname()}\ \ %F\ \ %{strftime('%Y-%m-%d\ %H:%M',getftime(expand('%')))}

" fix gbrowse when because netrw is disabled: https://vi.stackexchange.com/questions/38447/vim-fugitive-netrw-not-found-define-your-own-browse-to-use-gbrowse
:command! -nargs=1 Browse silent execute '!open' shellescape(<q-args>,1)

lua <<EOF

-- require("bufferline").setup {
--   options = {
--     name_formatter = function(buf) 
--       local MAX_LEN = 100
--       local ellipsis = string.char(0xE2, 0x80, 0xA6)
--       local str = buf.path:gsub("/Users/vaidask", "~") 
--       if string.len(str) > MAX_LEN then
--         str = ellipsis .. string.sub(str, -MAX_LEN + string.len(ellipsis))
--       end
--       return str
-- 
--     end,
--     max_name_length = 100
--   }
-- }

require("marks").setup {
  -- whether to map keybinds or not. default true
  default_mappings = true,
  -- which builtin marks to show. default {}
  builtin_marks = { ".", "<", ">", "^" },
  -- whether movements cycle back to the beginning/end of buffer. default true
  cyclic = true,
  -- whether the shada file is updated after modifying uppercase marks. default false
  force_write_shada = false,
  -- how often (in ms) to redraw signs/recompute mark positions. 
  -- higher values will have better performance but may cause visual lag, 
  -- while lower values may cause performance penalties. default 150.
  refresh_interval = 250,
  -- sign priorities for each type of mark - builtin marks, uppercase marks, lowercase
  -- marks, and bookmarks.
  -- can be either a table with all/none of the keys, or a single number, in which case
  -- the priority applies to all marks.
  -- default 10.
  sign_priority = { lower=10, upper=15, builtin=8, bookmark=20 },
  -- disables mark tracking for specific filetypes. default {}
  excluded_filetypes = {},
  -- marks.nvim allows you to configure up to 10 bookmark groups, each with its own
  -- sign/virttext. Bookmarks can be used to group together positions and quickly move
  -- across multiple buffers. default sign is '!@#$%^&*()' (from 0 to 9), and
  -- default virt_text is "".
  bookmark_0 = {
    sign = "⚑",
    virt_text = "hello world",
    -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
    -- defaults to false.
    annotate = false,
  },
   mappings = {
     annotate="M"
  }
}

require("live-command").setup {
  commands = {
    Norm = { cmd = "norm" },
  },
}

require("oil").setup {
  keymaps = {
    ["g?"] = "actions.show_help",
    ["<CR>"] = "actions.select",
    ["<C-s>"] = "actions.select_vsplit",
    -- ["<C-h>"] = "actions.select_split",
    ["<C-t>"] = "actions.select_tab",
    ["<C-p>"] = "actions.preview",
    ["<C-c>"] = "actions.close",
  -- ["<C-l>"] = "actions.refresh",
    ["-"] = "actions.parent",
    ["_"] = "actions.open_cwd",
    ["§"] = "actions.open_cmdline",
    ["~"] = "actions.open_cmdline_dir",
    ["gs"] = "actions.change_sort",
    ["gr"] = "actions.refresh",
    ["gx"] = "actions.open_external",
    ["g."] = "actions.toggle_hidden",
    ["g\\"] = "actions.toggle_trash",
  },
  -- Set to false to disable all of the above keymaps
  use_default_keymaps = false,
  view_options = {
    -- Show files and directories that start with "."
    show_hidden = true,
  },
}

vim.keymap.set("n", "-", "<CMD>Oil<CR>", { desc = "Open parent directory" })

require("neo-tree").setup({
  window = {
    mappings = {
      -- ["-"] = "navigate_up",
      ["[c"] = "prev_git_modified",
      ["]c"] = "next_git_modified",
    },
  },
  filesystem = {
    follow_current_file = true,
    group_empty_dirs = false,
    -- hijack_netrw_behavior = "open_current",
    window = {
      mappings = {
        -- disable fuzzy finder
        ["/"] = "noop"
      }
    },
    filtered_items = {
      visible = true, -- when true, they will just be displayed differently than normal items
    },
  },
})

require('aerial').setup({
  -- optionally use on_attach to set keymaps when aerial has attached to a buffer
  on_attach = function(bufnr)
    -- Jump forwards/backwards with '{' and '}'
    vim.keymap.set('n', '<C-p>', '<cmd>AerialPrev<CR>', {buffer = bufnr})
    vim.keymap.set('n', '<C-n>', '<cmd>AerialNext<CR>', {buffer = bufnr})
  end,
  layout = {
    -- These control the width of the aerial window.
    -- They can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
    -- min_width and max_width can be a list of mixed types.
    -- max_width = {40, 0.2} means "the lesser of 40 columns or 20% of total"
    max_width = { 50, 0.3 },
    width = nil,
    min_width = 20,

    -- key-value pairs of window-local options for aerial window (e.g. winhl)
    win_opts = { wrap = true },

    -- Determines the default direction to open the aerial window. The 'prefer'
    -- options will open the window in the other direction *if* there is a
    -- different buffer in the way of the preferred direction
    -- Enum: prefer_right, prefer_left, right, left, float
    default_direction = "prefer_left",

    -- Determines where the aerial window will be opened
    --   edge   - open aerial at the far right/left of the editor
    --   window - open aerial to the right/left of the current window
    placement = "window",

    -- Preserve window size equality with (:help CTRL-W_=)
    preserve_equality = false,
    },
})

require("github-theme").setup({
  theme_style = "dimmed",
  variable_style = "NONE",
  dark_float = true,
  colors = {
    syntax = {
      -- variable = '#00FF00',
      func = '#adbac7',
      constant = '#96d0ff',
      string = '#8ddb8c',
      variable = '#96d0ff',
    },
  }
})
-- require("noice").setup()
require("sad").setup({
  debug = false, -- print debug info
  diff = 'delta', -- you can use `less`, `diff-so-fancy`
  ls_file = 'fd', -- also git ls_file
  exact = false, -- exact match
  vsplit = false, -- split sad window the screen vertically, when set to number
  -- it is a threadhold when window is larger than the threshold sad will split vertically,
  height_ratio = 0.6, -- height ratio of sad window when split horizontally
  width_ratio = 0.6, -- height ratio of sad window when split vertically
})
-- You probably also want to set a keymap to toggle aerial
vim.keymap.set('n', '<leader>a', '<cmd>AerialToggle!<CR>')

require('neotest').setup({
  adapters = {
    require('neotest-jest')({
      jestCommand = "echo hello;",
      -- jestConfigFile = "custom.jest.config.ts",
      env = { CI = true },
      cwd = function(path)
        return vim.fn.system('find-package-root ' .. path)
      end,
    }),
  }
})

vim.keymap.set("n", "<leader>j", "<cmd>Portal jumplist backward<cr>")
-- vim.keymap.set("n", "<leader>i", "<cmd>Portal jumplist forward<cr>")

-- require("statuscol").setup(
--   {
--     foldfunc = "builtin",
--     setopt = true
--   }
-- )


vim.o.foldcolumn = "1" -- '0' is not bad
vim.o.foldlevel = 99 -- Using ufo provider need a large value, feel free to decrease the value
vim.o.foldlevelstart = 99
vim.o.foldenable = true
vim.o.foldcolumn = '1'
vim.o.fillchars = [[eob: ,fold: ,foldopen:,foldsep: ,foldclose:]]

-- these are "extra", change them as you like
vim.keymap.set("n", "zR", require("ufo").openAllFolds)
vim.keymap.set("n", "zM", function() 
  vim.o.foldlevel = 0 
end)
vim.keymap.set('n', 'K', function()
    local winid = require('ufo').peekFoldedLinesUnderCursor()
    if not winid then
        -- choose one of coc.nvim and nvim lsp
        vim.fn.CocActionAsync('definitionHover') -- coc.nvim
        vim.lsp.buf.hover()
    end
end)

local lineCountHandler = function(virtText, lnum, endLnum, width, truncate)
    local newVirtText = {}
    local suffix = ('  %d '):format(endLnum - lnum)
    local sufWidth = vim.fn.strdisplaywidth(suffix)
    local targetWidth = width - sufWidth
    local curWidth = 0
    for _, chunk in ipairs(virtText) do
        local chunkText = chunk[1]
        local chunkWidth = vim.fn.strdisplaywidth(chunkText)
        if targetWidth > curWidth + chunkWidth then
            table.insert(newVirtText, chunk)
        else
            chunkText = truncate(chunkText, targetWidth - curWidth)
            local hlGroup = chunk[2]
            table.insert(newVirtText, {chunkText, hlGroup})
            chunkWidth = vim.fn.strdisplaywidth(chunkText)
            -- str width returned from truncate() may less than 2nd argument, need padding
            if curWidth + chunkWidth < targetWidth then
                suffix = suffix .. (' '):rep(targetWidth - curWidth - chunkWidth)
            end
            break
        end
        curWidth = curWidth + chunkWidth
    end
    table.insert(newVirtText, {suffix, 'MoreMsg'})
    return newVirtText
end
-- Option 3: treesitter as a main provider instead
-- Only depend on `nvim-treesitter/queries/filetype/folds.scm`,
-- performance and stability are better than `foldmethod=nvim_treesitter#foldexpr()`
require("ufo").setup(
  {
    fold_virt_text_handler = lineCountHandler,
    provider_selector = function(bufnr, filetype, buftype)
      return {"treesitter", "indent"}
    end
  }
)


require("chatgpt").setup({
  openai_params = {
    model = "gpt-4",
    max_tokens = 2000,
  },
  keymaps = {
      close = { "<C-c>" },
      submit = "<S-CR>",
      yank_last = "<C-y>",
      yank_last_code = "<C-k>",
      scroll_up = "<C-u>",
      scroll_down = "<C-d>",
      toggle_settings = "<C-o>",
      new_session = "<C-n>",
      cycle_windows = "<Tab>",
      -- in the Sessions pane
      select_session = "<Space>",
      rename_session = "r",
      delete_session = "d",
    },
})

require('dressing').setup({
 select = {
   get_config = function(opts)
     if opts.kind == 'legendary.nvim' then
       return {
         telescope = {
           sorter = require('telescope.sorters').fuzzy_with_index_bias({})
         }
       }
     else
       return {}
     end
   end
 }
})

local wk = require("which-key");
wk.setup({})

local execWithRoot = require("findRoot").execWithRoot
wk.register({
e = { execWithRoot('cd ${MONOREPO_ROOT} | Files'), "find file in monorepo" },
g = {
  name = "Git",
  b = { "<cmd>Git blame<CR>", "Blame" },
  s = { "<cmd>Git<CR>", "Status" },
  h = { "<cmd>DiffviewFileHistory<CR>", "History" },
  f = { "<cmd>DiffviewFileHistory %<CR>", "History of current file" },
  d = { "<cmd>DiffviewOpen<CR>", "Diff" },
  v = { "<cmd>call git#git_diffview_commit()<CR>", "Diff of commit" },
  dh = { "<cmd>diffget //2<CR>", "Diff get left" },
  dl = { "<cmd>diffget //3<CR>", "Diff get right" },
  e = { "<cmd>Gedit<CR>", "Edit" },
  l = { "<cmd>0Gclog!<CR>", "Log" },
  c = { "<cmd>Git commit<CR>", "Commit" },
  w = { "<cmd>Git write<CR>", "Write" },
  p = {
    name = 'Publish',
    f = { "<cmd>Git push --force-with-lease<CR>", "Push force" },
    b = { "<cmd>Git pub <CR>", "Publish branch" },
  },
  -- gr = { function() vim.cmd("!gh pr view -w<CR>") end ,  "View PR on this branch" },
  r = { "<cmd>!gh pr view -w<CR>",  "View PR on this branch" },
},
o = {
  name = "Package",
  u = {function() 
        if vim.bo.filetype == 'neo-tree' then
          local state = require("neo-tree.sources.manager").get_state("filesystem")
          local node = state.tree:get_node()
          vim.pretty_print(node)
          if node.type == 'file' then
          else 
            vim.cmd(":Files " .. node.path)
          end
        end
      end, "find files in current directory"},
  p = { execWithRoot('edit ${PACKAGE_ROOT}/package.json'), "Edit package.json" },
  t = { execWithRoot('edit ${PACKAGE_ROOT}/tsconfig.json'), "Edit tsconfig.json" },
  n = { execWithRoot('edit ${PACKAGE_ROOT}/node_modules'), "Edit node_modules" },
  s = { execWithRoot('cd ${PACKAGE_ROOT} | pwd'), "Set cwd to package root" },
  x = { execWithRoot('call ExecutePackageScript("${PACKAGE_ROOT}")'), "Execute package script" },
  e = { execWithRoot('cd ${PACKAGE_ROOT} | Files'), "find file in package" },
  o = {
    name = "Monorepo",
    p = { execWithRoot('edit ${MONOREPO_ROOT}/package.json'), "Edit package.json" },
    t = { execWithRoot('edit ${MONOREPO_ROOT}/tsconfig.json'), "Edit tsconfig.json" },
    n = { execWithRoot('edit ${MONOREPO_ROOT}/node_modules'), "Edit node_modules" },
    s = { execWithRoot('cd ${MONOREPO_ROOT} | pwd'), "Set cwd to monorepo root" },
    x = { execWithRoot('call ExecutePackageScript("${MONOREPO_ROOT}")'), "Execute package script" },
    e = { execWithRoot('cd ${MONOREPO_ROOT} | Files'), "find file in monorepo" },
  }
  },
v = {
  name = "System config editing",
  s = {":so $MYVIMRC<cr>", "Source vimrc"},
  o = {":vsp $MYVIMRC<cr>", "Open vimrc in vertical split"},
  e = {":vsp ~/.vim/vimrc<cr>", "Edit ~/.vim/vimrc in vertical split"},
  n = {":CocCommand snippets.editSnippets<cr>", "Edit snippets"},
  d = {":vsp ~/dotfiles/<cr>", "Open ~/dotfiles/ in vertical split"},
  i = {":PlugInstall<cr>", "Run PlugInstall"},
  j = {":e ~/.config/txs/sessions.json<cr>", "Edit sessions.json"},
},
n = {
  name = "Obsidian",
  n = { "<cmd>ObsidianNew<CR>", "New note" },
  s = { "<cmd>ObsidianSearch<CR>", "Search" },
  t = { "<cmd>ObsidianToday<CR>", "Today" },
}

}, { prefix="<leader>" })

require("legendary").setup({
  extentions = {
    which_key = {
      auto_register = true,
      do_bindings = false,
    }
  }
})

require("obsidian").setup({
  dir = "~/Library/Mobile Documents/iCloud~md~obsidian/Documents/notesv1",
  notes_subdir = "daily-notes",
  completion = {
    nvim_cmp = false, -- if using nvim-cmp, otherwise set to false
  }
})

EOF

" hls colors
highlight Search ctermbg=black ctermfg=yellow cterm=underline guibg=yellow

" Alt-o
nmap <A-o> <Plug>EnhancedJumpsRemoteOlder
" Alt-i
nmap <A-i> <Plug>EnhancedJumpsRemoteNewer

" Leader keys: 
" q - quickfix list
" w - vimwiki group
" e - open fzf :Files
" r - replcase is in project
" y - FREE
:command! CopyBuffer let @+ = join([expand('%:p'),  line(".")], ':')
nnoremap <silent> <leader>y :CopyBuffer<CR>
" u - AI
nnoremap <leader>uu :ChatGPT<CR>
xnoremap <leader>uv :lua require'chatgpt'.edit_with_instructions()<CR>
" i - insert group

" p - paste yanked
nnoremap <silent> <leader>p "0p
nnoremap <silent> <leader>P "0P
" a - aerial
" s - splits
" d - debuger
" f - coc fzf - unused
" g - Git
" h - hunks
" j - FREE
" k - FREE
" l - nohls
" z - Format
" x - execute (tests)
nmap <silent><leader>xb <leader>os:terminal cd $(dirname %); yarn build<CR>
" c - FREE
" v - vim source/open etc
" b - Fzf Buffers:
" n - FREE
" m - FREE

hi CocInfoHighlight gui=undercurl guisp=#6bc46d

autocmd FileType chatgpt,neo-tree,fugitive,help,startify,dashboard,packer,neogitstatus,NvimTree,Trouble,alpha,lir,Outline,spectre_panel,toggleterm,qf, let b:nowinbar=1

function! AddWinBar()
    " Disable for all non-standard windows
    if win_gettype(bufwinnr('%')) != ''
        return
    endif
    " Don't strip on these filetypes
    if exists('b:nowinbar')
        return
    endif
    setlocal winbar=%#PathGroup#%{expand('%:~:h')}/%#FileNameGroup#%t%m
    highlight PathGroup guifg=gray guibg=black
    highlight FileNameGroup guifg=#f47067 guibg=black
endfunction

autocmd BufEnter * call AddWinBar()

hi CocSpellBad cterm=underline gui=underline ctermfg=Green guifg=Green

inoremap <C-,> <BS>
inoremap <C-b> <BS>

let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-x': 'split',
  \ 'ctrl-v': 'vsplit',
  \ 'ctrl-q': 'fill_quickfix'}

" for some broken monorepos
let g:editorconfig = v:false
